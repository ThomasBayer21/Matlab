<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATLAB Berechnungen - Interaktive Visualisierung</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #ff7979 0%, #e74c3c 100%);
            min-height: 100vh;
        }
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        .header a {
            color: white;
            text-decoration: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        .header a:hover {
            opacity: 1;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: -1px;
            flex-wrap: wrap;
        }
        .tab-button {
            padding: 12px 24px 18px 24px;
            background: rgba(255,255,255,0.3);
            border: none;
            border-radius: 8px 8px 0 0;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
        }
        .tab-button:hover {
            background: rgba(255,255,255,0.5);
        }
        .tab-button.active {
            background: white;
            color: #e74c3c;
        }
        .tab-button:first-child {
            border-radius: 12px 8px 0 0;
        }
        .content {
            background: white;
            border-radius: 0 12px 12px 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        h2 {
            color: #e74c3c;
            margin-top: 0;
        }
        .interactive-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: flex-end;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-size: 0.9em;
            color: #555;
            font-weight: 600;
        }
        input[type="number"], input[type="text"], select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
        }
        button {
            padding: 10px 20px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s;
        }
        button:hover {
            background: #c0392b;
        }
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .code-block .comment {
            color: #75715e;
        }
        .code-block .function {
            color: #66d9ef;
        }
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .result-display {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #e74c3c;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .matrix-display {
            display: inline-grid;
            gap: 5px;
            margin: 10px;
        }
        .matrix-cell {
            min-width: 60px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f0f0;
            border: 2px solid #e74c3c;
            border-radius: 4px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        .matrix-label {
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0;
        }
        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
        }
        .vector-visual {
            width: 100%;
            height: 300px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin: 15px 0;
        }
        .calc-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .calc-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        .calc-card h3 {
            margin-top: 0;
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>MATLAB Berechnungen</h1>
        <p><a href="../index.html">← Zurück zur Übersicht</a></p>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab-button active" onclick="showTab('numerisch')">Numerische Berechnungen</button>
            <button class="tab-button" onclick="showTab('linalg')">Lineare Algebra</button>
            <button class="tab-button" onclick="showTab('vektoren')">Vektoroperationen</button>
            <button class="tab-button" onclick="showTab('trigonometrie')">Trigonometrie</button>
        </div>

        <div class="content">
            <!-- Numerische Berechnungen Tab -->
            <div id="numerisch" class="tab-content active">
                <h2>Numerische Berechnungen</h2>
                <p>MATLAB bietet leistungsstarke Funktionen für numerische Differentiation, Integration und Interpolation.</p>

                <div class="interactive-section">
                    <h3>Interaktive Numerische Operationen</h3>
                    <p>Wählen Sie eine oder mehrere Funktionen und sehen Sie diff(), cumsum() und interp1() in Aktion:</p>
                    <div class="controls">
                        <div class="control-group">
                            <label>Funktion(en) auswählen:</label>
                            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                <label><input type="checkbox" value="sin" onchange="updateNumerical()" checked> sin(x)</label>
                                <label><input type="checkbox" value="cos" onchange="updateNumerical()"> cos(x)</label>
                                <label><input type="checkbox" value="exp" onchange="updateNumerical()"> exp(x/5)</label>
                                <label><input type="checkbox" value="poly" onchange="updateNumerical()"> x²</label>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Anzahl Datenpunkte:</label>
                            <input type="range" id="numPoints" min="10" max="50" value="20" oninput="updateNumerical(); document.getElementById('numPointsVal').textContent=this.value;">
                            <span id="numPointsVal">20</span>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <h4 style="text-align: center;">Original & Differentiation (diff)</h4>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="diffChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h4 style="text-align: center;">Original & Integration (cumsum)</h4>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="cumsumChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <h4 style="margin-top: 20px;">Interpolation (interp1)</h4>
                    <div class="controls">
                        <div class="control-group">
                            <label>Methode:</label>
                            <select id="interpMethod" onchange="updateNumerical()">
                                <option value="linear">Linear</option>
                                <option value="step">Nearest (Stufenfunktion)</option>
                            </select>
                        </div>
                    </div>
                    <p style="font-size: 0.9em; color: #666;">Originaldaten (grob) werden auf feineres Gitter interpoliert:</p>
                    <div class="chart-container">
                        <canvas id="interpChart"></canvas>
                    </div>
                    <div class="code-block" id="numericalCode"></div>
                </div>

                <div class="info-box">
                    <strong>Wichtige numerische Funktionen:</strong><br>
                    <code>diff(x)</code> - Differenzen zwischen Elementen (Ableitung)<br>
                    <code>cumsum(x)</code> - Kumulative Summe (Integration)<br>
                    <code>interp1(x, y, xq)</code> - 1D-Interpolation<br>
                    <code>trapz(x, y)</code> - Trapezregel-Integration<br>
                    <code>integral(f, a, b)</code> - Numerische Integration einer Funktion
                </div>
            </div>

            <!-- Lineare Algebra Tab -->
            <div id="linalg" class="tab-content">
                <h2>Lineare Algebra</h2>
                <p>MATLAB ist besonders stark in der linearen Algebra - der Name steht für "Matrix Laboratory"!</p>

                <h3>Lineares Gleichungssystem lösen</h3>
                <div class="interactive-section">
                    <p>Löse das Gleichungssystem: A·x = b (3×3 System)</p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div class="control-group">
                            <label>Matrix A (Zeilen mit Semikolon getrennt):</label>
                            <input type="text" id="matrixA" value="2, 1, -1; -3, -1, 2; -2, 1, 2" style="width: 100%;">
                        </div>
                        <div class="control-group">
                            <label>Vektor b (Kommagetrennt):</label>
                            <input type="text" id="vectorB" value="8, -11, -3" style="width: 100%;">
                        </div>
                    </div>
                    <div class="controls">
                        <button onclick="solveLinearSystem()">Lösen</button>
                    </div>
                    <div id="linSysDisplay"></div>
                    <div class="result-display" id="linSysResult"></div>
                    <div class="code-block" id="linSysCode"></div>
                </div>

                <h3>Matrix-Operationen</h3>
                <div class="calc-grid">
                    <div class="calc-card">
                        <h3>Transponieren</h3>
                        <div class="code-block">A' <span class="comment">% oder transpose(A)</span></div>
                        <p>Vertauscht Zeilen und Spalten</p>
                    </div>

                    <div class="calc-card">
                        <h3>Inverse</h3>
                        <div class="code-block">inv(A)
A^-1</div>
                        <p>Berechnet die inverse Matrix</p>
                    </div>

                    <div class="calc-card">
                        <h3>Determinante</h3>
                        <div class="code-block">det(A)</div>
                        <p>Berechnet die Determinante</p>
                    </div>

                    <div class="calc-card">
                        <h3>Rang</h3>
                        <div class="code-block">rank(A)</div>
                        <p>Gibt den Rang der Matrix zurück</p>
                    </div>

                    <div class="calc-card">
                        <h3>Eigenwerte</h3>
                        <div class="code-block">[V, D] = eig(A)</div>
                        <p>V: Eigenvektoren, D: Eigenwerte</p>
                    </div>

                    <div class="calc-card">
                        <h3>Norm</h3>
                        <div class="code-block">norm(A)
norm(A, 'fro')</div>
                        <p>Verschiedene Matrixnormen</p>
                    </div>
                </div>

                <div class="interactive-section">
                    <h3>Interaktiver Matrix-Rechner</h3>
                    <div class="controls">
                        <div class="control-group">
                            <label>Matrix A:</label>
                            <input type="text" id="matA" value="2,1;3,4" placeholder="z.B. 1,2;3,4">
                        </div>
                        <div class="control-group">
                            <label>Operation:</label>
                            <select id="matOp">
                                <option value="transpose">Transponieren</option>
                                <option value="inverse">Inverse</option>
                                <option value="det">Determinante</option>
                                <option value="rank">Rang</option>
                            </select>
                        </div>
                        <button onclick="calculateMatrix()">Berechnen</button>
                    </div>
                    <div class="result-display" id="matResult"></div>
                </div>

                <div class="info-box">
                    <strong>Wichtig:</strong> Der Backslash-Operator <code>\</code> ist effizienter als <code>inv(A)*b</code> zum Lösen von Gleichungssystemen!<br>
                    <code>x = A \ b</code> statt <code>x = inv(A) * b</code>
                </div>
            </div>

            <!-- Vektoroperationen Tab -->
            <div id="vektoren" class="tab-content">
                <h2>Vektoroperationen</h2>
                <p>MATLAB bietet umfangreiche Funktionen für Vektorberechnungen.</p>

                <h3>Skalarprodukt (Dot Product)</h3>
                <div class="interactive-section">
                    <p>Das Skalarprodukt zweier Vektoren: a · b = a₁b₁ + a₂b₂ + a₃b₃</p>
                    <div class="controls">
                        <div class="control-group">
                            <label>Vektor a:</label>
                            <input type="text" id="vecA_dot" value="1, 2, 3">
                        </div>
                        <div class="control-group">
                            <label>Vektor b:</label>
                            <input type="text" id="vecB_dot" value="4, 5, 6">
                        </div>
                        <button onclick="calculateDot()">Berechnen</button>
                    </div>
                    <div class="result-display" id="dotResult"></div>
                    <div class="code-block">a = [1, 2, 3];
b = [4, 5, 6];
dot(a, b)     <span class="comment">% oder a * b'</span></div>
                </div>

                <h3>Kreuzprodukt (Cross Product)</h3>
                <div class="interactive-section">
                    <p>Das Kreuzprodukt ergibt einen Vektor senkrecht zu beiden Eingabevektoren.</p>
                    <div class="controls">
                        <div class="control-group">
                            <label>Vektor a:</label>
                            <input type="text" id="vecA_cross" value="1, 0, 0">
                        </div>
                        <div class="control-group">
                            <label>Vektor b:</label>
                            <input type="text" id="vecB_cross" value="0, 1, 0">
                        </div>
                        <button onclick="calculateCross()">Berechnen</button>
                    </div>
                    <div class="result-display" id="crossResult"></div>
                    <canvas id="crossCanvas" class="vector-visual"></canvas>
                    <div class="code-block">a = [1, 0, 0];
b = [0, 1, 0];
cross(a, b)  <span class="comment">% Ergebnis: [0, 0, 1]</span></div>
                </div>

                <h3>Vektornorm (Länge)</h3>
                <div class="interactive-section">
                    <div class="controls">
                        <div class="control-group">
                            <label>Vektor:</label>
                            <input type="text" id="vecNorm" value="3, 4">
                        </div>
                        <button onclick="calculateNorm()">Berechnen</button>
                    </div>
                    <div class="result-display" id="normResult"></div>
                    <div class="code-block">v = [3, 4];
norm(v)       <span class="comment">% Euklidische Norm (L2)</span>
sqrt(v * v')  <span class="comment">% Alternative Berechnung</span></div>
                </div>

                <div class="info-box">
                    <strong>Vektorfunktionen:</strong><br>
                    <code>dot(a, b)</code> - Skalarprodukt<br>
                    <code>cross(a, b)</code> - Kreuzprodukt (nur 3D)<br>
                    <code>norm(v)</code> - Euklidische Norm (Länge)<br>
                    <code>norm(v, p)</code> - p-Norm<br>
                    <code>normalize(v)</code> - Normalisiert Vektor auf Länge 1
                </div>
            </div>

            <!-- Trigonometrie Tab -->
            <div id="trigonometrie" class="tab-content">
                <h2>Trigonometrische Funktionen</h2>
                <p>MATLAB unterstützt trigonometrische Funktionen sowohl in Radiant als auch in Grad.</p>

                <div class="calc-grid">
                    <div class="calc-card">
                        <h3>Radiant-Funktionen</h3>
                        <div class="code-block">sin(x)
cos(x)
tan(x)
asin(x)
acos(x)
atan(x)</div>
                        <p>Standard: Radiant (π = 180°)</p>
                    </div>

                    <div class="calc-card">
                        <h3>Grad-Funktionen</h3>
                        <div class="code-block">sind(x)
cosd(x)
tand(x)
asind(x)
acosd(x)
atand(x)</div>
                        <p>Mit 'd' am Ende: Grad</p>
                    </div>
                </div>

                <div class="interactive-section">
                    <h3>Interaktiver Trigonometrie-Rechner</h3>
                    <div class="controls">
                        <div class="control-group">
                            <label>Funktion:</label>
                            <select id="trigFunc">
                                <option value="sin">sin</option>
                                <option value="cos">cos</option>
                                <option value="tan">tan</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Eingabe:</label>
                            <input type="number" id="trigInput" value="90" step="1">
                        </div>
                        <div class="control-group">
                            <label>Einheit:</label>
                            <select id="trigUnit">
                                <option value="deg">Grad (°)</option>
                                <option value="rad">Radiant</option>
                            </select>
                        </div>
                        <button onclick="calculateTrig()">Berechnen</button>
                    </div>
                    <div class="result-display" id="trigResult"></div>
                    <div class="chart-container">
                        <canvas id="trigChart"></canvas>
                    </div>
                </div>

                <h3>Umrechnungen</h3>
                <div class="interactive-section">
                    <div class="controls">
                        <div class="control-group">
                            <label>Wert:</label>
                            <input type="number" id="convValue" value="90" step="1">
                        </div>
                        <div class="control-group">
                            <label>Konvertierung:</label>
                            <select id="convType">
                                <option value="deg2rad">Grad → Radiant</option>
                                <option value="rad2deg">Radiant → Grad</option>
                            </select>
                        </div>
                        <button onclick="convertAngle()">Umrechnen</button>
                    </div>
                    <div class="result-display" id="convResult"></div>
                    <div class="code-block">deg2rad(90)   <span class="comment">% = π/2 ≈ 1.5708</span>
rad2deg(pi)   <span class="comment">% = 180</span></div>
                </div>

                <div class="info-box">
                    <strong>Wichtig:</strong><br>
                    • <code>sin(90)</code> ≠ 1, weil 90 als Radiant interpretiert wird!<br>
                    • <code>sind(90)</code> = 1, weil 90 als Grad interpretiert wird<br>
                    • π (pi) ist eine vordefinierte Konstante in MATLAB<br>
                    • Hyperbolische Funktionen: <code>sinh()</code>, <code>cosh()</code>, <code>tanh()</code>
                </div>
            </div>
        </div>
    </div>

    <script>
        let diffChart, cumsumChart, interpChart, trigChart;

        function showTab(tabName) {
            const tabs = document.querySelectorAll('.tab-content');
            const buttons = document.querySelectorAll('.tab-button');

            tabs.forEach(tab => tab.classList.remove('active'));
            buttons.forEach(btn => btn.classList.remove('active'));

            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        function updateNumerical() {
            // Hole ausgewählte Funktionen
            const checkboxes = document.querySelectorAll('input[type="checkbox"]:checked');
            const selectedFuncs = Array.from(checkboxes).map(cb => cb.value);

            if (selectedFuncs.length === 0) {
                return;
            }

            const numPoints = parseInt(document.getElementById('numPoints').value);
            const interpMethod = document.getElementById('interpMethod').value;

            // Generiere Daten
            const x = Array.from({length: numPoints}, (_, i) => i * 10 / (numPoints - 1));

            // Erstelle Datasets für jede ausgewählte Funktion
            const colors = {
                sin: '#e74c3c',
                cos: '#3498db',
                exp: '#9b59b6',
                poly: '#e67e22'
            };

            const funcNames = {
                sin: 'sin(x)',
                cos: 'cos(x)',
                exp: 'exp(x/5)',
                poly: 'x²'
            };

            // Code-String
            let code = '% Numerische Operationen\n';
            code += `x = linspace(0, 10, ${numPoints});\n\n`;

            // === DIFF CHART ===
            const diffDatasets = [];
            selectedFuncs.forEach(func => {
                let y;
                switch(func) {
                    case 'sin': y = x.map(v => Math.sin(v)); code += `y_sin = sin(x);\n`; break;
                    case 'cos': y = x.map(v => Math.cos(v)); code += `y_cos = cos(x);\n`; break;
                    case 'exp': y = x.map(v => Math.exp(v / 5)); code += `y_exp = exp(x/5);\n`; break;
                    case 'poly': y = x.map(v => v * v / 20); code += `y_poly = x.^2 / 20;\n`; break;
                }

                const dy = [];
                for (let i = 1; i < y.length; i++) {
                    dy.push(y[i] - y[i-1]);
                }

                diffDatasets.push({
                    label: funcNames[func],
                    data: y,
                    borderColor: colors[func],
                    fill: false,
                    pointRadius: 0
                });
                diffDatasets.push({
                    label: `diff(${funcNames[func]})`,
                    data: dy,
                    borderColor: colors[func],
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0
                });
            });

            if (diffChart) diffChart.destroy();
            diffChart = new Chart(document.getElementById('diffChart'), {
                type: 'line',
                data: {
                    labels: x,
                    datasets: diffDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: true } }
                }
            });

            // === CUMSUM CHART ===
            const cumsumDatasets = [];
            selectedFuncs.forEach(func => {
                let y;
                switch(func) {
                    case 'sin': y = x.map(v => Math.sin(v)); break;
                    case 'cos': y = x.map(v => Math.cos(v)); break;
                    case 'exp': y = x.map(v => Math.exp(v / 5)); break;
                    case 'poly': y = x.map(v => v * v / 20); break;
                }

                const cumY = [];
                let sum = 0;
                y.forEach(v => {
                    sum += v;
                    cumY.push(sum);
                });

                cumsumDatasets.push({
                    label: funcNames[func],
                    data: y,
                    borderColor: colors[func],
                    fill: false,
                    pointRadius: 0
                });
                cumsumDatasets.push({
                    label: `cumsum(${funcNames[func]})`,
                    data: cumY,
                    borderColor: colors[func],
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    borderWidth: 2
                });
            });

            if (cumsumChart) cumsumChart.destroy();
            cumsumChart = new Chart(document.getElementById('cumsumChart'), {
                type: 'line',
                data: {
                    labels: x,
                    datasets: cumsumDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: true } }
                }
            });

            // === INTERPOLATION CHART ===
            const interpDatasets = [];

            // Nimm nur jeden 4. Punkt als Original-Datenpunkte
            const xSparse = x.filter((_, i) => i % 4 === 0);
            const xFine = Array.from({length: numPoints * 4}, (_, i) => i * 10 / (numPoints * 4 - 1));

            selectedFuncs.forEach(func => {
                let ySparse;
                switch(func) {
                    case 'sin': ySparse = xSparse.map(v => Math.sin(v)); break;
                    case 'cos': ySparse = xSparse.map(v => Math.cos(v)); break;
                    case 'exp': ySparse = xSparse.map(v => Math.exp(v / 5)); break;
                    case 'poly': ySparse = xSparse.map(v => v * v / 20); break;
                }

                // Interpoliere
                let yFine;
                if (interpMethod === 'linear') {
                    yFine = xFine.map(xv => {
                        for (let i = 0; i < xSparse.length - 1; i++) {
                            if (xv >= xSparse[i] && xv <= xSparse[i+1]) {
                                const t = (xv - xSparse[i]) / (xSparse[i+1] - xSparse[i]);
                                return ySparse[i] + t * (ySparse[i+1] - ySparse[i]);
                            }
                        }
                        return ySparse[ySparse.length - 1];
                    });
                } else { // step
                    yFine = xFine.map(xv => {
                        let minDist = Infinity;
                        let nearest = 0;
                        xSparse.forEach((xp, i) => {
                            const dist = Math.abs(xv - xp);
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = i;
                            }
                        });
                        return ySparse[nearest];
                    });
                }

                interpDatasets.push({
                    label: `${funcNames[func]} (Original)`,
                    data: xSparse.map((xv, i) => ({ x: xv, y: ySparse[i] })),
                    borderColor: colors[func],
                    backgroundColor: colors[func],
                    pointRadius: 6,
                    showLine: false
                });
                interpDatasets.push({
                    label: `interp1 (${interpMethod})`,
                    data: xFine.map((xv, i) => ({ x: xv, y: yFine[i] })),
                    borderColor: colors[func],
                    pointRadius: 0,
                    fill: false
                });
            });

            if (interpChart) interpChart.destroy();
            interpChart = new Chart(document.getElementById('interpChart'), {
                type: 'line',
                data: { datasets: interpDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { type: 'linear' },
                        y: { type: 'linear' }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            // Code
            code += `\n% Differentiation\n`;
            selectedFuncs.forEach(func => {
                code += `dy_${func} = diff(y_${func});\n`;
            });

            code += `\n% Integration (kumulative Summe)\n`;
            selectedFuncs.forEach(func => {
                code += `cumY_${func} = cumsum(y_${func});\n`;
            });

            code += `\n% Interpolation\n`;
            code += `x_sparse = x(1:4:end);  % Jeder 4. Punkt\n`;
            selectedFuncs.forEach(func => {
                code += `y_sparse = y_${func}(1:4:end);\n`;
            });
            code += `x_fine = linspace(0, 10, ${numPoints * 4});\n`;
            code += `y_interp = interp1(x_sparse, y_sparse, x_fine, '${interpMethod}');`;

            document.getElementById('numericalCode').textContent = code;
        }

        function solveLinearSystem() {
            try {
                // Parse Eingaben
                const matrixAStr = document.getElementById('matrixA').value;
                const vectorBStr = document.getElementById('vectorB').value;

                const A = matrixAStr.split(';').map(row =>
                    row.split(',').map(v => parseFloat(v.trim()))
                );
                const b = vectorBStr.split(',').map(v => parseFloat(v.trim()));

                // Validierung
                if (A.length !== 3 || A.some(row => row.length !== 3)) {
                    alert('Matrix A muss 3×3 sein!');
                    return;
                }
                if (b.length !== 3) {
                    alert('Vektor b muss 3 Elemente haben!');
                    return;
                }

                // Determinante berechnen (für 3x3)
                function det3x3(m) {
                    return m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -
                           m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
                           m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
                }

                const detA = det3x3(A);

                if (Math.abs(detA) < 1e-10) {
                    document.getElementById('linSysResult').textContent =
                        'Fehler: Matrix A ist singulär (det(A) = 0)\nKeine eindeutige Lösung!';
                    return;
                }

                // Cramers Regel: x_i = det(A_i) / det(A)
                const x = [];
                for (let i = 0; i < 3; i++) {
                    const Ai = A.map(row => [...row]);
                    for (let j = 0; j < 3; j++) {
                        Ai[j][i] = b[j];
                    }
                    x.push(det3x3(Ai) / detA);
                }

                // Anzeige
                let html = '<div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">';
                html += '<div><strong>Matrix A:</strong>';
                html += '<div class="matrix-display" style="grid-template-columns: repeat(3, 60px);">';
                A.forEach(row => row.forEach(v => html += `<div class="matrix-cell">${v}</div>`));
                html += '</div></div>';

                html += '<div><strong>Vektor b:</strong>';
                html += '<div class="matrix-display" style="grid-template-columns: 60px;">';
                b.forEach(v => html += `<div class="matrix-cell">${v}</div>`);
                html += '</div></div>';

                html += '<div><strong>Lösung x:</strong>';
                html += '<div class="matrix-display" style="grid-template-columns: 80px;">';
                x.forEach(v => html += `<div class="matrix-cell" style="background: #2ecc71; color: white;">${v.toFixed(3)}</div>`);
                html += '</div></div>';
                html += '</div>';

                document.getElementById('linSysDisplay').innerHTML = html;

                // Verifikation
                const verify = [];
                for (let i = 0; i < 3; i++) {
                    let sum = 0;
                    for (let j = 0; j < 3; j++) {
                        sum += A[i][j] * x[j];
                    }
                    verify.push(sum);
                }

                const isCorrect = verify.every((v, i) => Math.abs(v - b[i]) < 0.001);

                document.getElementById('linSysResult').textContent =
                    'Lösung x:\n' +
                    x.map((v, i) => `x${i+1} = ${v.toFixed(6)}`).join('\n') +
                    '\n\nVerifikation: A * x = ' +
                    `[${verify.map(v => v.toFixed(3)).join(', ')}]` +
                    (isCorrect ? ' ✓' : ' ✗');

                // Code
                const matStr = A.map(row => row.join(', ')).join('; ');
                document.getElementById('linSysCode').textContent =
                    `A = [${matStr}];\n` +
                    `b = [${b.join('; ')}];\n` +
                    `x = A \\ b  % Backslash-Operator löst A·x = b\n` +
                    `% Lösung: x = [${x.map(v => v.toFixed(3)).join('; ')}]`;

            } catch (error) {
                alert('Fehler beim Parsen der Eingabe: ' + error.message);
            }
        }

        function calculateMatrix() {
            const matStr = document.getElementById('matA').value;
            const op = document.getElementById('matOp').value;

            try {
                const rows = matStr.split(';').map(r => r.split(',').map(v => parseFloat(v.trim())));
                const n = rows.length;
                const m = rows[0].length;

                let result = '';

                if (op === 'transpose') {
                    const trans = Array(m).fill(0).map((_, i) =>
                        Array(n).fill(0).map((_, j) => rows[j][i])
                    );
                    result = 'Transponierte Matrix:\n' +
                        trans.map(r => r.join('  ')).join('\n');
                } else if (op === 'det' && n === m && n === 2) {
                    const det = rows[0][0] * rows[1][1] - rows[0][1] * rows[1][0];
                    result = `Determinante: ${det.toFixed(4)}`;
                } else if (op === 'inverse' && n === m && n === 2) {
                    const det = rows[0][0] * rows[1][1] - rows[0][1] * rows[1][0];
                    const inv = [
                        [rows[1][1]/det, -rows[0][1]/det],
                        [-rows[1][0]/det, rows[0][0]/det]
                    ];
                    result = 'Inverse Matrix:\n' +
                        inv.map(r => r.map(v => v.toFixed(4)).join('  ')).join('\n');
                } else if (op === 'rank') {
                    result = `Rang: ${Math.min(n, m)} (vereinfachte Schätzung)`;
                }

                document.getElementById('matResult').textContent = result;
            } catch(e) {
                document.getElementById('matResult').textContent = 'Fehler: ' + e.message;
            }
        }

        function calculateDot() {
            const a = document.getElementById('vecA_dot').value.split(',').map(v => parseFloat(v.trim()));
            const b = document.getElementById('vecB_dot').value.split(',').map(v => parseFloat(v.trim()));

            const dot = a.reduce((sum, v, i) => sum + v * b[i], 0);

            document.getElementById('dotResult').textContent =
                `a = [${a.join(', ')}]\n` +
                `b = [${b.join(', ')}]\n\n` +
                `Skalarprodukt: ${dot.toFixed(4)}\n\n` +
                `Berechnung: ${a.map((v, i) => `${v}×${b[i]}`).join(' + ')} = ${dot.toFixed(4)}`;
        }

        function calculateCross() {
            const a = document.getElementById('vecA_cross').value.split(',').map(v => parseFloat(v.trim()));
            const b = document.getElementById('vecB_cross').value.split(',').map(v => parseFloat(v.trim()));

            const cross = [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];

            document.getElementById('crossResult').textContent =
                `a = [${a.join(', ')}]\n` +
                `b = [${b.join(', ')}]\n\n` +
                `Kreuzprodukt: [${cross.map(v => v.toFixed(4)).join(', ')}]\n\n` +
                `Das Ergebnis steht senkrecht auf a und b.`;

            drawVectors(a, b, cross);
        }

        function drawVectors(a, b, c) {
            const canvas = document.getElementById('crossCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const scale = 40;

            // Isometrische Projektion: 3D -> 2D
            function project3D(x, y, z) {
                // Isometrische Projektion: rotiere um Y und X Achse
                const isoX = (x - z) * Math.cos(Math.PI / 6);
                const isoY = y + (x + z) * Math.sin(Math.PI / 6);
                return {
                    x: cx + isoX * scale,
                    y: cy - isoY * scale
                };
            }

            // Zeichne 3D-Achsen
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // X-Achse (rot)
            let p1 = project3D(0, 0, 0);
            let p2 = project3D(3, 0, 0);
            ctx.strokeStyle = '#ffcccc';
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.fillStyle = '#888';
            ctx.font = '12px Arial';
            ctx.fillText('X', p2.x + 5, p2.y);

            // Y-Achse (grün)
            p2 = project3D(0, 3, 0);
            ctx.strokeStyle = '#ccffcc';
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.fillText('Y', p2.x, p2.y - 5);

            // Z-Achse (blau)
            p2 = project3D(0, 0, 3);
            ctx.strokeStyle = '#ccccff';
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.fillText('Z', p2.x + 5, p2.y);

            ctx.setLineDash([]);

            // Zeichne Vektoren
            const origin = project3D(0, 0, 0);

            // Vektor a (rot)
            const endA = project3D(a[0], a[1], a[2]);
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            drawArrow(ctx, origin.x, origin.y, endA.x, endA.y);
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('a', endA.x + 10, endA.y);

            // Vektor b (blau)
            const endB = project3D(b[0], b[1], b[2]);
            ctx.strokeStyle = '#3498db';
            drawArrow(ctx, origin.x, origin.y, endB.x, endB.y);
            ctx.fillStyle = '#3498db';
            ctx.fillText('b', endB.x + 10, endB.y);

            // Kreuzprodukt c (grün)
            const endC = project3D(c[0], c[1], c[2]);
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 4;
            drawArrow(ctx, origin.x, origin.y, endC.x, endC.y);
            ctx.fillStyle = '#2ecc71';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('a × b', endC.x + 10, endC.y);

            // Legende
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('Isometrische 3D-Ansicht', 10, 20);
            ctx.fillStyle = '#2ecc71';
            ctx.fillText('⬤ Kreuzprodukt steht ⊥ zu a und b', 10, canvas.height - 10);
        }

        function drawArrow(ctx, x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 10 * Math.cos(angle - Math.PI/6), y2 - 10 * Math.sin(angle - Math.PI/6));
            ctx.lineTo(x2 - 10 * Math.cos(angle + Math.PI/6), y2 - 10 * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fill();
        }

        function calculateNorm() {
            const v = document.getElementById('vecNorm').value.split(',').map(x => parseFloat(x.trim()));
            const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));

            document.getElementById('normResult').textContent =
                `v = [${v.join(', ')}]\n\n` +
                `||v|| = √(${v.map(x => `${x}²`).join(' + ')}) = ${norm.toFixed(4)}`;
        }

        function calculateTrig() {
            const func = document.getElementById('trigFunc').value;
            const input = parseFloat(document.getElementById('trigInput').value);
            const unit = document.getElementById('trigUnit').value;

            let result;
            const rad = unit === 'deg' ? input * Math.PI / 180 : input;

            switch(func) {
                case 'sin': result = Math.sin(rad); break;
                case 'cos': result = Math.cos(rad); break;
                case 'tan': result = Math.tan(rad); break;
            }

            const funcName = unit === 'deg' ? func + 'd' : func;
            document.getElementById('trigResult').textContent =
                `${funcName}(${input}) = ${result.toFixed(6)}\n\n` +
                `MATLAB Code: ${funcName}(${input})`;

            updateTrigChart(func, unit);
        }

        function updateTrigChart(func, unit) {
            const isDeg = unit === 'deg';
            const points = isDeg ? 360 : 628; // 628 ≈ 2π * 100
            const x = Array.from({length: points}, (_, i) => isDeg ? i : i / 100);
            let y;

            if (isDeg) {
                switch(func) {
                    case 'sin': y = x.map(v => Math.sin(v * Math.PI / 180)); break;
                    case 'cos': y = x.map(v => Math.cos(v * Math.PI / 180)); break;
                    case 'tan': y = x.map(v => {
                        const t = Math.tan(v * Math.PI / 180);
                        return Math.abs(t) > 10 ? null : t;
                    }); break;
                }
            } else {
                switch(func) {
                    case 'sin': y = x.map(v => Math.sin(v)); break;
                    case 'cos': y = x.map(v => Math.cos(v)); break;
                    case 'tan': y = x.map(v => {
                        const t = Math.tan(v);
                        return Math.abs(t) > 10 ? null : t;
                    }); break;
                }
            }

            if (trigChart) trigChart.destroy();
            trigChart = new Chart(document.getElementById('trigChart'), {
                type: 'line',
                data: {
                    labels: x.map(v => v.toFixed(isDeg ? 0 : 2)),
                    datasets: [{
                        label: func + '(x)',
                        data: y,
                        borderColor: '#e74c3c',
                        fill: false,
                        pointRadius: 0,
                        spanGaps: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: isDeg ? 'Winkel (°)' : 'Winkel (rad)' },
                            ticks: { maxTicksLimit: 12 }
                        },
                        y: { title: { display: true, text: func + '(x)' }, min: -2, max: 2 }
                    }
                }
            });
        }

        function convertAngle() {
            const value = parseFloat(document.getElementById('convValue').value);
            const type = document.getElementById('convType').value;

            let result, code;

            if (type === 'deg2rad') {
                result = value * Math.PI / 180;
                code = `deg2rad(${value})`;
            } else {
                result = value * 180 / Math.PI;
                code = `rad2deg(${value})`;
            }

            document.getElementById('convResult').textContent =
                `${code} = ${result.toFixed(6)}`;
        }

        // Initialisierung
        window.onload = function() {
            updateNumerical();
            solveLinearSystem();
            calculateMatrix();
            calculateDot();
            calculateCross();
            calculateNorm();
            calculateTrig();
            convertAngle();
        };
    </script>
</body>
</html>
